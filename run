#!/usr/bin/env bash
ORIGINAL_USER=$SUDO_USER  # Capture the original user for yay

# Colors and formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

# Symbols
CHECK_MARK="${GREEN}✓${RESET}"
CROSS_MARK="${RED}✗${RESET}"
ARROW="${CYAN}→${RESET}"
INFO="${BLUE}ℹ${RESET}"
WARNING="${YELLOW}⚠${RESET}"

# Log and backup directories
LOG_DIR="blackarch_logs"
MAIN_LOG="$LOG_DIR/installation.log"
BACKUP_DIR="$LOG_DIR/backups"

# Required tools and their corresponding packages
declare -A tool_packages=( 
    ["aircrack-ng"]="aircrack-ng"
    ["tshark"]="wireshark-cli"
    ["wireshark"]="wireshark-qt"
    ["nmap"]="nmap"
    ["msfconsole"]="metasploit"
    ["john"]="john"
    ["hydra"]="hydra"
    ["sqlmap"]="sqlmap"
    ["burpsuite"]="burpsuite"
    ["nikto"]="nikto"
    ["gobuster"]="gobuster"
    ["dirb"]="dirb"
    ["wfuzz"]="wfuzz"
    ["ffuf"]="ffuf"
    ["whatweb"]="whatweb"
    ["wpscan"]="wpscan"
    ["joomscan"]="joomscan"
    ["droopescan"]="droopescan"
    ["cmsmap"]="cmsmap"
    ["dnsenum"]="dnsenum"
    ["dnsrecon"]="dnsrecon"
    ["dnsmap"]="dnsmap"
    ["dnswalk"]="dnswalk"
    ["fierce"]="fierce"
    ["dnsdict6"]="dnsdict6"
    ["dnsbrute"]="dnsbrute"
)

# Function to display a styled header
print_header() {
    local text="$1"
    local width=80
    local padding=$(( (width - ${#text}) / 2 ))
    
    echo -e "\n${BOLD}${PURPLE}"
    printf "%$(($width))s\n" | tr ' ' '═'
    printf "%${padding}s${text}%${padding}s\n"
    printf "%$(($width))s\n" | tr ' ' '═'
    echo -e "${RESET}"
}

# Function to display a step heading with spinner
print_step() {
    local step="$1"
    local description="$2"
    local spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
    local i=0
    
    echo -ne "\n${BOLD}${BLUE}[${CYAN}$step${BLUE}]${RESET} ${BOLD}$description${RESET} "
    for ((j=0; j<12; j++)); do
        echo -ne "${YELLOW}${spinner[$i]}${RESET}"
        sleep 0.08
        echo -ne "\b"
        i=$(( (i + 1) % 10 ))
    done
    echo -e "\n"
}

# Function to display progress
print_progress() {
    local current="$1"
    local total="$2"
    local percentage=$(( current * 100 / total ))
    local completed=$(( percentage / 2 ))
    local remaining=$(( 50 - completed ))
    
    printf "${BOLD}[${GREEN}"
    printf "%0.s█" $(seq 1 $completed)
    printf "${YELLOW}"
    printf "%0.s▒" $(seq 1 $remaining)
    printf "${RESET}${BOLD}] ${percentage}%%${RESET} ($current/$total)\n"
}

# Function to log messages
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    mkdir -p "$LOG_DIR"
    echo "[$timestamp] [$level] $message" >> "$MAIN_LOG"
    
    case "$level" in
        "SUCCESS") echo -e "${CHECK_MARK} $message" ;;
        "WARNING") echo -e "${WARNING} $message" ;;
        "ERROR") echo -e "${CROSS_MARK} $message" ;;
        "INFO") echo -e "${INFO} $message" ;;
        *) ;;
    esac
}

# Function to check if running as root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        log_message "ERROR" "Please run this script as root with sudo"
        exit 1
    fi
    if [ -z "$ORIGINAL_USER" ]; then
        log_message "ERROR" "Cannot determine original user. Please run with sudo."
        exit 1
    fi
}

# Function to add BlackArch repository
add_blackarch_repo() {
    print_step "REPO" "Setting up BlackArch Repositories"
    
    if ! grep -q "\[blackarch\]" /etc/pacman.conf; then
        log_message "INFO" "Setting up repos please wait ..."
        curl -O https://blackarch.org/strap.sh > /dev/null 2>&1
        chmod +x strap.sh > /dev/null 2>&1
        ./strap.sh > /dev/null 2>&1
        rm -rf strap.sh
        log_message "SUCCESS" "BlackArch repositories added successfully"
    else
        log_message "INFO" "BlackArch repository already added"
    fi
}

# Function to update package databases
update_databases() {
    print_step "UPDATE" "Synchronizing Package Databases"
    log_message "INFO" "Synchronizing package databases..."
    pacman -Sy > /dev/null 2>&1
    log_message "SUCCESS" "Package databases updated successfully"
}

# Function to install yay (AUR helper)
install_yay() {
    print_step "AUR" "Installing yay (AUR Helper)"
    if ! command -v yay &> /dev/null; then
        log_message "INFO" "Installing yay..."
        pacman -S --noconfirm --needed git base-devel > /dev/null 2>&1
        git clone https://aur.archlinux.org/yay.git /tmp/yay > /dev/null 2>&1
        cd /tmp/yay
        makepkg -si --noconfirm > /dev/null 2>&1
        cd /tmp
        rm -rf yay
        if [ $? -eq 0 ]; then
            log_message "SUCCESS" "yay installed successfully"
        else
            log_message "ERROR" "Failed to install yay"
            exit 1
        fi
    else
        log_message "INFO" "yay is already installed"
    fi
}

# Function to install required dependencies
install_dependencies() {
    print_step "DEPS" "Installing Required Dependencies"
    local dependencies=("base-devel" "libnl" "openssl" "ethtool" "util-linux" "zlib" "libpcap" "sqlite" "pcre2" "hwloc" "cmocka" "hostapd" "wpa_supplicant" "tcpdump" "screen" "iw" "usbutils" "pciutils" "expect")
    log_message "INFO" "Installing dependencies: ${dependencies[*]}"
    pacman -S --noconfirm --needed "${dependencies[@]}" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        log_message "SUCCESS" "Dependencies installed successfully"
    else
        log_message "ERROR" "Failed to install some dependencies"
    fi
}

# Function to check and install required tools
check_and_install_tools() {
    print_step "TOOLS" "Checking and Installing Required Tools"
    local missing_tools=()
    
    for cmd in "${!tool_packages[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_tools+=("$cmd")
        fi
    done
    
    if [ ${#missing_tools[@]} -eq 0 ]; then
        log_message "SUCCESS" "All required tools are installed"
    else
        log_message "WARNING" "Missing tools: ${missing_tools[*]}"
        echo -e "${BOLD}${YELLOW}Some tools are missing. Attempting to install...${RESET}"
        for cmd in "${missing_tools[@]}"; do
            local package=${tool_packages[$cmd]}
            echo -e "\n${BOLD}Installing $package for command $cmd...${RESET}"
            if pacman -Si "$package" &> /dev/null; then
                pacman -S --noconfirm --needed "$package" > /dev/null 2>&1
                if [ $? -eq 0 ]; then
                    log_message "SUCCESS" "Installed $package"
                    echo -e "${CHECK_MARK} Installed $package"
                else
                    log_message "ERROR" "Failed to install $package with pacman"
                    echo -e "${CROSS_MARK} Failed to install $package with pacman"
                fi
            else
                echo -e "${INFO} $package not found in official repos, trying AUR..."
                sudo -u "$ORIGINAL_USER" yay -S --noconfirm --needed "$package" > /dev/null 2>&1
                if [ $? -eq 0 ]; then
                    log_message "SUCCESS" "Installed $package from AUR"
                    echo -e "${CHECK_MARK} Installed $package from AUR"
                else
                    log_message "ERROR" "Failed to install $package from AUR"
                    echo -e "${CROSS_MARK} Failed to install $package from AUR"
                fi
            fi
        done
    fi
}

# Function to install AUR packages
install_aur_packages() {
    print_step "AUR-PKGS" "Installing AUR Packages"
    local aur_packages=("apkid")
    log_message "INFO" "Installing AUR packages: ${aur_packages[*]}"
    for package in "${aur_packages[@]}"; do
        if ! pacman -Q "$package" &>/dev/null; then
            sudo -u "$ORIGINAL_USER" yay -S --noconfirm "$package" > /dev/null 2>&1
            if [ $? -eq 0 ]; then
                log_message "SUCCESS" "Installed AUR package: $package"
            else
                log_message "ERROR" "Failed to install AUR package: $package"
            fi
        else
            log_message "INFO" "AUR package $package already installed"
        fi
    done
}

# Function to get BlackArch packages
get_blackarch_packages() {
    print_step "PACKAGES" "Retrieving BlackArch Package List"
    log_message "INFO" "Getting list of BlackArch packages..."
    pacman -Slq blackarch > blackarch_packages.txt
    echo "android-apktool" >> blackarch_packages.txt  # Ensure android-apktool is included
    local total=$(wc -l < blackarch_packages.txt)
    log_message "SUCCESS" "Found ${total} BlackArch packages"
}

# Function to handle file conflicts
handle_file_conflicts() {
    local package="$1"
    local error_msg="$2"
    
    log_message "WARNING" "Resolving file conflicts for $package..."
    mkdir -p "$BACKUP_DIR/$package"
    local conflicting_files=$(echo "$error_msg" | grep "exists in filesystem" | sed -E 's/.*: (\/.*) exists in filesystem.*/\1/')
    
    [ -z "$conflicting_files" ] && { log_message "ERROR" "Could not identify conflicting files."; return 1; }
    
    echo "$conflicting_files" | while read -r file; do
        [ -n "$file" ] || continue
        log_message "WARNING" "Conflicting file detected: $file"
        local owner=$(pacman -Qo "$file" 2>/dev/null | awk '{print $NF}')
        
        if [ -n "$owner" ]; then
            log_message "INFO" "File owned by package: $owner"
            if [[ "$owner" == *"-git"* ]] || [[ "$owner" != *"$package"* ]]; then
                log_message "WARNING" "Removing conflicting package: $owner"
                pacman -R --noconfirm "$owner" > /dev/null 2>&1 && log_message "SUCCESS" "Removed $owner" || {
                    log_message "WARNING" "Failed to remove $owner. Backing up file..."
                    stat -c "%a %u %g" "$file" > "$BACKUP_DIR/$package/$(basename "$file").meta" 2>/dev/null
                    cp "$file" "$BACKUP_DIR/$package/$(basename "$file").$(date +%Y%m%d%H%M%S)" 2>/dev/null
                    mv "$file" "${file}.backup" 2>/dev/null
                }
            else
                log_message "INFO" "Backing up conflicting file..."
                stat -c "%a %u %g" "$file" > "$BACKUP_DIR/$package/$(basename "$file").meta" 2>/dev/null
                cp "$file" "$BACKUP_DIR/$package/$(basename "$file").$(date +%Y%m%d%H%M%S)" 2>/dev/null
                mv "$file" "${file}.backup" 2>/dev/null
            fi
        else
            log_message "INFO" "File not owned, backing up..."
            stat -c "%a %u %g" "$file" > "$BACKUP_DIR/$package/$(basename "$file").meta" 2>/dev/null
            cp "$file" "$BACKUP_DIR/$package/$(basename "$file").$(date +%Y%m%d%H%M%S)" 2>/dev/null
            mv "$file" "${file}.backup" 2>/dev/null
        fi
    done
    return 0
}

# Function to handle dependency issues
handle_dependency_issues() {
    local package="$1"
    local error_msg="$2"
    
    log_message "WARNING" "Resolving dependency issues for $package..."
    log_message "INFO" "Trying --overwrite flag..."
    pacman -S --noconfirm --overwrite="*" "$package" > /dev/null 2>&1 && { log_message "SUCCESS" "Installed with --overwrite"; return 0; }
    
    log_message "INFO" "Trying --needed flag..."
    pacman -S --noconfirm --needed "$package" > /dev/null 2>&1 && { log_message "SUCCESS" "Installed with --needed"; return 0; }
    
    local missing_deps=$(echo "$error_msg" | grep -o "dependency.*required" | sed -E 's/dependency (.*) is required.*/\1/')
    if [ -n "$missing_deps" ]; then
        log_message "INFO" "Installing missing dependencies: $missing_deps"
        for dep in $missing_deps; do
            pacman -S --noconfirm --needed "$dep" > /dev/null 2>&1
        done
        log_message "INFO" "Retrying $package installation..."
        pacman -S --noconfirm --needed "$package" > /dev/null 2>&1 && { log_message "SUCCESS" "Installed after resolving dependencies"; return 0; }
    fi
    return 1
}

# Function to clean up backups
cleanup_backups() {
    print_step "CLEANUP" "Managing Backup Files"
    local backup_count=$(find / -name "*.backup" 2>/dev/null | wc -l)
    
    if [ "$backup_count" -gt 0 ]; then
        log_message "INFO" "Found $backup_count backup files"
        echo -e "${YELLOW}${BOLD}╭───────────────────────────────────────────────────────╮${RESET}"
        echo -e "${YELLOW}${BOLD}│ Backup Management Options                             │${RESET}"
        echo -e "${YELLOW}${BOLD}╰───────────────────────────────────────────────────────╯${RESET}"
        echo -e "  ${CYAN}1${RESET}. ${BOLD}Keep backups${RESET} - Leave all backup files in place"
        echo -e "  ${CYAN}2${RESET}. ${BOLD}Move backups${RESET} - Relocate to $BACKUP_DIR/system_backups"
        echo -e "  ${CYAN}3${RESET}. ${BOLD}Remove all${RESET} - Delete all backup files from system"
        echo -ne "\n${BOLD}Choose an option [1-3]:${RESET} "
        read -r choice
        
        case $choice in
            2)
                log_message "INFO" "Moving backups..."
                mkdir -p "$BACKUP_DIR/system_backups"
                find / -name "*.backup" 2>/dev/null | while read -r file; do
                    mkdir -p "$BACKUP_DIR/system_backups/$(dirname "${file#/}")"
                    mv "$file" "$BACKUP_DIR/system_backups/${file#/}" 2>/dev/null
                    log_message "INFO" "Moved: $file"
                done
                log_message "SUCCESS" "Backups moved to $BACKUP_DIR/system_backups"
                ;;
            3)
                log_message "WARNING" "Removing backups..."
                find / -name "*.backup" 2>/dev/null -delete
                log_message "SUCCESS" "All backups removed"
                ;;
            *) log_message "INFO" "Keeping backups in place" ;;
        esac
    else
        log_message "INFO" "No backups found"
    fi
}

# Function to install packages
install_packages() {
    print_step "INSTALL" "Installing BlackArch Packages"
    local start_time=$(date +%s)
    local total=$(wc -l < blackarch_packages.txt)
    local current=0 successful=0 failed=0 skipped=0
    local failed_packages="" skipped_packages=""
    local max_retries=2
    
    mkdir -p "$LOG_DIR/package_logs"
    echo -e "${CYAN}${BOLD}┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓${RESET}"
    echo -e "${CYAN}${BOLD}┃                 Starting BlackArch Package Installation            ┃${RESET}"
    echo -e "${CYAN}${BOLD}┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛${RESET}\n"
    
    while read -r package; do
        current=$((current + 1))
        echo -e "\n${YELLOW}${BOLD}╭───────────────────────────────────────────────────────╮${RESET}"
        printf "${YELLOW}${BOLD}│ %-51s │${RESET}\n" "PACKAGE: $package"
        echo -e "${YELLOW}${BOLD}╰───────────────────────────────────────────────────────╯${RESET}"
        print_progress $current $total
        
        if pacman -Q "$package" &>/dev/null; then
            echo -e "${YELLOW}⚠ Package $package already installed, skipping...${RESET}"
            log_message "INFO" "Package $package already installed, skipping..."
            skipped=$((skipped + 1))
            skipped_packages="$skipped_packages$package (already installed)\n"
            continue
        fi
        
        local retry=0 installed=false error_output=""
        while [ $retry -lt $max_retries ] && [ "$installed" = false ]; do
            retry=$((retry + 1))
            echo -ne "Attempt $retry of $max_retries: Installing..."
            error_output=$(pacman -S --noconfirm "$package" 2>&1)
            if [ $? -eq 0 ]; then
                tput cuu1; tput el
                echo -e "Attempt $retry: ${GREEN}✓ Success${RESET}"
                log_message "SUCCESS" "Installed $package on attempt $retry"
                successful=$((successful + 1))
                installed=true
            else
                tput cuu1; tput el
                echo -e "Attempt $retry: ${RED}✗ Failed${RESET}"
                log_message "ERROR" "Failed $package on attempt $retry. Analyzing..."
                echo "$error_output" > "$LOG_DIR/package_logs/${package}_error.log"
                
                if echo "$error_output" | grep -q "conflicting files"; then
                    handle_file_conflicts "$package" "$error_output"
                elif echo "$error_output" | grep -q "dependency"; then
                    handle_dependency_issues "$package" "$error_output"
                else
                    log_message "ERROR" "Unknown error. See $LOG_DIR/package_logs/${package}_error.log"
                fi
            fi
            sleep 1
        done
        
        if [ "$installed" = false ]; then
            log_message "ERROR" "Failed $package after $max_retries retries"
            failed=$((failed + 1))
            failed_packages="$failed_packages$package\n"
        fi
        sleep 0.5
    done < blackarch_packages.txt
    
    local end_time=$(date +%s)
    local elapsed=$((end_time - start_time))
    local hours=$((elapsed / 3600)) minutes=$(((elapsed % 3600) / 60)) seconds=$((elapsed % 60))
    
    print_step "SUMMARY" "Installation Results"
    echo -e "${BOLD}${GREEN}┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓${RESET}"
    echo -e "${BOLD}${GREEN}┃                        Installation Summary                       ┃${RESET}"
    echo -e "${BOLD}${GREEN}┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛${RESET}\n"
    
    echo -e "${BOLD}${GREEN}Success:${RESET} $successful packages"
    echo -e "${BOLD}${RED}Failed:${RESET} $failed packages"
    echo -e "${BOLD}${YELLOW}Skipped:${RESET} $skipped packages"
    echo -e "${BOLD}Time taken:${RESET} ${hours}h ${minutes}m ${seconds}s"
    
    [ $failed -gt 0 ] && {
        echo -e "\n${BOLD}${RED}Failed packages:${RESET}\n$failed_packages"
        echo -e "$failed_packages" | sed '/^$/d' > "$LOG_DIR/failed_packages.txt"
    }
    [ $skipped -gt 0 ] && {
        echo -e "\n${BOLD}${YELLOW}Skipped packages:${RESET}\n$skipped_packages"
        echo -e "$skipped_packages" | sed '/^$/d' > "$LOG_DIR/skipped_packages.txt"
    }
}

# Improved function to retry failed packages with yay without repeatedly asking for password
retry_failed_packages_with_yay() {
    print_step "RETRY" "Retrying Failed Packages with yay"
    
    if [ ! -s "$LOG_DIR/failed_packages.txt" ]; then
        log_message "INFO" "No failed packages to retry"
        return 0
    fi
    
    local total_failed=$(wc -l < "$LOG_DIR/failed_packages.txt")
    log_message "INFO" "Found $total_failed packages to retry with yay"
    
    echo -e "${YELLOW}${BOLD}╭───────────────────────────────────────────────────────╮${RESET}"
    echo -e "${YELLOW}${BOLD}│ Retrying Failed Packages with yay                     │${RESET}"
    echo -e "${YELLOW}${BOLD}╰───────────────────────────────────────────────────────╯${RESET}"
    
    # Create a temporary script to run with sudo -u $ORIGINAL_USER
    local temp_script="/tmp/retry_packages.sh"
    
    echo '#!/bin/bash' > "$temp_script"
    echo "echo 'Starting batch installation of failed packages with yay'" >> "$temp_script"
    echo "echo 'This may take some time, please be patient...'" >> "$temp_script"
    echo "failed_count=0" >> "$temp_script"
    echo "success_count=0" >> "$temp_script"
    
    # Add each package to the script
    local count=0
    while IFS= read -r pkg || [ -n "$pkg" ]; do
        count=$((count + 1))
        echo "echo -e \"\\n[$count/$total_failed] Attempting to install $pkg with yay...\"" >> "$temp_script"
        echo "yay -S --noconfirm $pkg > /dev/null 2>&1" >> "$temp_script"
        echo "if [ \$? -eq 0 ]; then" >> "$temp_script"
        echo "  echo -e \"\\033[0;32m✓\\033[0m Successfully installed $pkg\"" >> "$temp_script"
        echo "  success_count=\$((success_count + 1))" >> "$temp_script"
        echo "else" >> "$temp_script"
        echo "  echo -e \"\\033[0;31m✗\\033[0m Failed to install $pkg\"" >> "$temp_script"
        echo "  failed_count=\$((failed_count + 1))" >> "$temp_script"
        echo "  echo \"$pkg\" >> /tmp/still_failed_packages.txt" >> "$temp_script"
        echo "fi" >> "$temp_script"
    done < "$LOG_DIR/failed_packages.txt"
    
    echo "echo -e \"\\n-----------------------------------\"" >> "$temp_script"
    echo "echo -e \"\\033[1mRetry Summary:\\033[0m\"" >> "$temp_script"
    echo "echo -e \"\\033[0;32mSuccessfully installed:\\033[0m \$success_count packages\"" >> "$temp_script"
    echo "echo -e \"\\033[0;31mFailed to install:\\033[0m \$failed_count packages\"" >> "$temp_script"
    
    # Make it executable
    chmod +x "$temp_script"
    
    # Run the script as the original user
    sudo -u "$ORIGINAL_USER" "$temp_script"
    
    # Copy the still failed packages list if it exists
    if [ -f "/tmp/still_failed_packages.txt" ]; then
        cp "/tmp/still_failed_packages.txt" "$LOG_DIR/still_failed_packages.txt"
        rm "/tmp/still_failed_packages.txt"
        log_message "WARNING" "Some packages still failed to install. See $LOG_DIR/still_failed_packages.txt"
    else
        log_message "SUCCESS" "All failed packages were successfully installed with yay"
    fi
    
    # Clean up
    rm "$temp_script"
}

# Function to handle internal fix script
run_fix_script() {
    print_step "FIX" "Running Package Fix Script"
    
    if [ ! -s "$LOG_DIR/still_failed_packages.txt" ] && [ ! -s "$LOG_DIR/failed_packages.txt" ]; then
        log_message "INFO" "No packages require fixing"
        return 0
    fi
    
    echo -e "${BOLD}${BLUE}Some packages may have failed to install.${RESET}"
    echo -e "${BOLD}Would you like to attempt to run the internal fixing mechanism?${RESET}"
    echo -e "${YELLOW}${BOLD}Note:${RESET} Not recommended if you are new to Arch Linux packaging system."
    echo -ne "${BOLD}Run fix script? [y/n]:${RESET} "
    read -r answer

    if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
        if [[ -x "./fix" ]]; then
            log_message "INFO" "Running fix script for remaining failed packages..."
            chmod +x ./fix
            ./fix
            log_message "INFO" "Fix script completed"
        else
            log_message "ERROR" "Fix script not found or not executable in the current directory"
        fi
    else
        log_message "INFO" "Skipping fix script"
    fi
}

# Function to offer selective install
offer_selective_install() {
    print_step "SELECTION" "Package Selection Method"
    echo -e "${BLUE}${BOLD}╭───────────────────────────────────────────────────────╮${RESET}"
    echo -e "${BLUE}${BOLD}│ How would you like to install BlackArch?              │${RESET}"
    echo -e "${BLUE}${BOLD}╰───────────────────────────────────────────────────────╯${RESET}"
    echo -e "  ${CYAN}1${RESET}. ${BOLD}All packages${RESET} - Full BlackArch installation"
    echo -e "  ${CYAN}2${RESET}. ${BOLD}Specific group${RESET} - Install packages from a specific category"
    echo -e "  ${CYAN}3${RESET}. ${BOLD}Custom list${RESET} - Use your own package list file (should be named as blacklist.txt)"
    echo -ne "\n${BOLD}Choose an option [1-3]:${RESET} "
    read -r choice
    
    case $choice in
        1) log_message "INFO" "Full installation selected" ;;
        2)
            echo -e "\n${BOLD}${BLUE}Available BlackArch Groups:${RESET}"
            pacman -Sg | grep blackarch | sort | column
            echo -ne "\n${BOLD}Enter group name:${RESET} "
            read -r group_name
            pacman -Sgq "$group_name" > blackarch_packages.txt
            echo "android-apktool" >> blackarch_packages.txt  # Ensure android-apktool is included
            log_message "SUCCESS" "Found $(wc -l < blackarch_packages.txt) packages in $group_name"
            ;;
        3)
            echo -ne "\n${BOLD}Enter path to package list:${RESET} "
            read -r custom_list
            [ -f "$custom_list" ] && cp "$custom_list" blacklist.txt || { log_message "ERROR" "File not found"; exit 1; }
            echo "android-apktool" >> blacklist.txt  # Ensure android-apktool is included
            log_message "SUCCESS" "Using custom list with $(wc -l < blacklist.txt) packages"
            ;;
        *) log_message "ERROR" "Invalid choice"; exit 1 ;;
    esac
}

# Function to clean package cache
clean_package_cache() {
    print_step "CACHE" "Package Cache Management"
    local cache_size=$(du -sh /var/cache/pacman/pkg/ | cut -f1)
    echo -e "${BOLD}${BLUE}Current package cache size:${RESET} $cache_size"
    echo -e "${YELLOW}${BOLD}Note:${RESET} Cleaning the cache will free up disk space but remove downloaded packages"
    echo -ne "${BOLD}Clean package cache? [y/n]:${RESET} "
    read -r answer
    
    [[ "$answer" =~ ^[Yy]$ ]] && {
        log_message "INFO" "Cleaning package cache..."
        pacman -Sc --noconfirm > /dev/null 2>&1
        log_message "SUCCESS" "Cache cleaned. New size: $(du -sh /var/cache/pacman/pkg/ | cut -f1)"
    } || log_message "INFO" "Cache cleanup skipped"
}

# Function to display banner
show_banner() {
    clear
    cat << 'EOF'
  
    ██████╗ ██╗      █████╗  ██████╗██╗  ██╗ █████╗ ██████╗  ██████╗██╗  ██╗
    ██╔══██╗██║     ██╔══██╗██╔════╝██║ ██╔╝██╔══██╗██╔══██╗██╔════╝██║  ██║
    ██████╔╝██║     ███████║██║     █████╔╝ ███████║██████╔╝██║     ███████║
    ██╔══██╗██║     ██╔══██║██║     ██╔═██╗ ██╔══██║██╔══██╗██║     ██╔══██║
    ██████╔╝███████╗██║  ██║╚██████╗██║  ██╗██║  ██║██║  ██║╚██████╗██║  ██║
    ╚═════╝ ╚══════╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝
                                                                          
EOF
    echo -e "${BOLD}${BLUE}     KYGO v2 latest - THE ARCH PENTESTING-TUNER  ${RESET}"
    echo -e "${YELLOW}         Engineered by 0xb0rn3 | github.com/0xb0rn3${RESET}\n"
}

# Function to handle interruptions
handle_interrupt() {
    echo -e "\n${BOLD}${RED}┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓${RESET}"
    echo -e "${BOLD}${RED}┃                        Process Interrupted!                       ┃${RESET}"
    echo -e "${BOLD}${RED}┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛${RESET}\n"
    echo -ne "${BOLD}Run backup cleanup before exiting? [y/n]:${RESET} "
    read -r answer
    [[ "$answer" =~ ^[Yy]$ ]] && cleanup_backups
    exit 1
}

# Main function to orchestrate the installation process
main() {
    show_banner
    mkdir -p "$LOG_DIR" "$BACKUP_DIR"
    # Set up interrupt handler
    trap handle_interrupt SIGINT SIGTERM
    print_header "BlackArch Installation Tool"
    # Check if running as root
    check_root
    # Add BlackArch repositories
    add_blackarch_repo
    # Update package databases
    update_databases
    # Install yay
    install_yay
    # Install dependencies
    install_dependencies
    # Check and install required tools
    check_and_install_tools
    # Install AUR packages
    install_aur_packages
    # Get BlackArch packages
    get_blackarch_packages
    # Ask for installation type
    offer_selective_install
    # Install packages
    install_packages
    # Retry failed packages with yay
    retry_failed_packages_with_yay
    # Run fix script if needed
    run_fix_script
    # Clean up backups
    cleanup_backups
    # Clean package cache
    clean_package_cache
    
    print_header "Installation Complete!"
    log_message "SUCCESS" "BlackArch installation process completed"
    echo -e "${BOLD}${GREEN}Installation logs available at: $LOG_DIR${RESET}"
}

# Run main function
main
